package polygraphicprogram;

import polygraphicprogram.*;
import polygraphicprogram.types.*;
import tom.library.sl.*;

public class PolygraphicProgram{

%include { polygraphicprogram/PolygraphicProgram.tom }
%include { sl.tom }


public static void main(String[] args) {

//jeu de cellules pour les tests : 

//1-chemin reprsentant les entiers naturels
	OnePath nat=`OneCell("nat");
//constructeurs sur les entiers naturels
	TwoPath zero=`TwoCell("zero",Id(),nat,Constructor());
	TwoPath succ =`TwoCell("succ",nat,nat,Constructor());
//2-cellules de structure
	TwoPath eraser= `TwoCell("eraser",nat,Id(),Structure());
	TwoPath duplication= `TwoCell("duplication",nat,OneC0(nat,nat),Structure());
	TwoPath permutation = `TwoCell("permutation",OneC0(nat,nat),OneC0(nat,nat),Structure());
//addition, soustraction et division
	TwoPath plus = `TwoCell("plus",OneC0(nat,nat),nat,Function());
	TwoPath minus = `TwoCell("minus",OneC0(nat,nat),nat,Function());
	TwoPath division = `TwoCell("division",OneC0(nat,nat),nat,Function());
	TwoPath multiplication = `TwoCell("multiplication",OneC0(nat,nat),nat,Function());
//3-cellules de structure
	ThreePath zeroPerm1 = `ThreeCell("zeroPerm1",TwoC1(TwoC0(zero,TwoId(nat)),permutation),TwoC0(TwoId(nat),zero),Structure());
	ThreePath zeroPerm2 = `ThreeCell("zeroPerm1",TwoC1(TwoC0(TwoId(nat),zero),permutation),TwoC0(zero,TwoId(nat)),Structure());
	ThreePath zeroDup = `ThreeCell("zeroDup",TwoC1(zero,duplication),TwoC0(zero,zero),Structure());
	ThreePath zeroEraz = `ThreeCell("zeroEraz",TwoC1(zero,eraser),TwoId(Id()),Structure());
	ThreePath succPerm1 = `ThreeCell("succPerm1",TwoC1(TwoC0(succ,TwoId(nat)),permutation),TwoC0(TwoId(nat),succ),Structure());
	ThreePath succPerm2 = `ThreeCell("succPerm1",TwoC1(TwoC0(TwoId(nat),succ),permutation),TwoC0(succ,TwoId(nat)),Structure());
	ThreePath succDup = `ThreeCell("succDup",TwoC1(succ,duplication),TwoC1(duplication,TwoC0(succ,succ)),Structure());
	ThreePath succEraz = `ThreeCell("succEraz",TwoC1(succ,eraser),TwoC1(TwoId(nat),eraser),Structure());
//regles
	ThreePath plusZero = `ThreeCell("plusZero",TwoC1(TwoC0(zero,TwoId(nat)),plus),TwoId(nat),Function());
	ThreePath plusSucc = `ThreeCell("plusSucc",TwoC1(TwoC0(succ,TwoId(nat)),plus),TwoC1(plus,succ),Function());
	ThreePath minusZero1 = `ThreeCell("minusZero1",TwoC1(TwoC0(zero,TwoId(nat)),minus),TwoC1(eraser,zero),Function());
	ThreePath minusZero2 = `ThreeCell("minusZero1",TwoC1(TwoC0(TwoId(nat),zero),minus),TwoId(nat),Function());
	ThreePath minusDoubleSucc = `ThreeCell("minusDoubleSucc",TwoC1(TwoC0(succ,succ),minus),minus,Function());
	ThreePath divZero = `ThreeCell("divZero",TwoC1(TwoC0(zero,TwoId(nat)),division),TwoC1(eraser,zero),Function());	
	ThreePath divSucc = `ThreeCell("divSucc",TwoC1(TwoC0(succ,TwoId(nat)),division),TwoC1(TwoC0(TwoId(nat),duplication),TwoC0(minus,TwoId(nat)),division,succ),Function());
	ThreePath multZero = `ThreeCell("multZero",TwoC1(TwoC0(zero,TwoId(nat)),multiplication),TwoC1(eraser,zero),Function());	
	ThreePath multSucc = `ThreeCell("multSucc",TwoC1(TwoC0(succ,TwoId(nat)),multiplication),TwoC1(TwoC0(TwoId(nat),duplication),TwoC0(multiplication,TwoId(nat)),plus),Function());


/*
TwoPath test=`TwoC0(TwoId(nat),TwoId(nat),zero,TwoC1(zero,succ),TwoId(nat),succ);
splitting(test);
splitting2(test);
TwoPath source=`TwoC0(TwoId(OneC0(OneCell("nat"),OneCell("nat"))),TwoCell("zero",Id(),OneCell("nat"),Constructor()),TwoId(OneC0(OneCell("nat"),OneCell("nat"))));
TwoPath target=`TwoC0(TwoId(OneCell("nat")),TwoId(OneCell("nat")),TwoCell("zero",Id(),OneCell("nat"),Constructor()),TwoCell("succ",OneCell("nat"),OneCell("nat"),Constructor()),TwoId(OneCell("nat")),TwoCell("succ",OneCell("nat"),OneCell("nat"),Constructor()));
System.out.println(`TwoC1(source,target).defined());
TwoPath test2=`TwoC0(TwoId(OneCell("nat")),TwoId(OneC0(OneCell("nat"),OneCell("nat"))));
*/
TwoPath testGravity=`TwoC1(TwoC0(zero,succ,succ),TwoC0(succ,TwoId(nat),eraser));
gravity(testGravity);
tom.library.utils.Viewer.display(testGravity);
try{
testGravity = (TwoPath) `Gravity().visit(testGravity);

tom.library.utils.Viewer.display(testGravity);}
catch(VisitFailure e) {
      throw new tom.engine.exception.TomRuntimeException("strange term: " + testGravity);
    }
}

//tests de transformations vers une forme normale (en faisant descendre tous les TwoCells) avant que a devienne des stratgies o les System.out.println() seront des return...
public static void splitting(TwoPath t){//splitting
%match (t){
		 TwoC0(head*,TwoC1(f@TwoCell(_,_,_,_),g@TwoCell(_,_,_,_)),tail*) -> {System.out.println(`TwoC1(TwoC0(head,f,tail),TwoC0(TwoId(head.target()),g,TwoId(tail.target()))));} 
		
}
// TwoC1(X*,TwoC0(head*,TwoC1(f@TwoCell(_,_,_,_),g@TwoCell(_,_,_,_)),tail*),Y*)->{System.out.println(`TwoC1(X*,TwoC0(head,f,tail),TwoC0(TwoId(head.target()),g,TwoId(tail.target())),Y*));} 
}
public static void splitting2(TwoPath t){// splitting plus rapide : on fait tomber un peu de gravity dans les head et tail
%match (t){
		 TwoC0(head*,TwoC1(f@TwoCell(_,_,_,_),g@TwoCell(_,_,_,_)),tail*) -> {System.out.println(`TwoC1(TwoC0(TwoId(head.source()),f,TwoId(tail.source())),TwoC0(head,g,tail)));} 

}
// TwoC1(X*,TwoC0(head*,TwoC1(f@TwoCell(_,_,_,_),g@TwoCell(_,_,_,_)),tail*),Y*)-> {System.out.println(`TwoC1(X*,TwoC0(TwoId(head.source()),f,TwoId(tail.source())),TwoC0(head,g,tail),Y*));} 
}
public static void horizontalsplitting(TwoPath t){//marche bien mais qu'une fois et il faut que le motif soit ˆ la racine
%match (t){
			TwoId(OneC0(head,tail*)) -> { System.out.println(`TwoC0(TwoId(head),TwoId(tail*))); }
}
}
public static void gravity(TwoPath t){//gravity ajouterhead* et tail* apres dans le TwoC1()?
%match (t){
			TwoC1(TwoC0(head1*,f@TwoCell(_,_,_,_),tail1*),TwoC0(head2*,X,tail2*)) -> { if(`X.isTwoId()&&`head1*.target()==`head2*.source()&&`tail1*.target()==`tail2*.source()&&`f.target()==`X.source()){System.out.println(`TwoC1(TwoC0(head1*,TwoId(f.source()),tail1*),TwoC0(head2*,f,tail2*)));}}
			
}
//TwoC1(head*,TwoC0(head1*,f@TwoCell(_,_,_,_),tail1*),TwoC0(head2*,X,tail2*),tail*) -> { if(`head1*.target()==`head2*.source()&&`tail1*.target()==`tail2*.source()&&`f.target()==`X.source()){System.out.println(`TwoC1(head*,TwoC0(head1*,TwoId(f.source()),tail1*),TwoC0(head2*,f,tail2*),tail*));}}
}



%strategy Print() extends Identity(){ 
  	visit TwoPath {
  	  x -> { System.out.println(`x); } 
 	 } 
}

%strategy Gravity() extends Fail(){ 
  	visit TwoPath {
  	  TwoC1(TwoC0(head1*,f@TwoCell(_,_,_,_),tail1*),TwoC0(head2*,X,tail2*)) -> { if(`X.isTwoId()&&`head1*.target()==`head2*.source()&&`tail1*.target()==`tail2*.source()&&`f.target()==`X.source()){return `TwoC1(TwoC0(head1*,TwoId(f.source()),tail1*),TwoC0(head2*,f,tail2*));}}
 } 
}

%strategy VerticalSplitting() extends Fail(){ 
  	visit TwoPath {
  	 TwoC0(head*,TwoC1(f@TwoCell(_,_,_,_),g@TwoCell(_,_,_,_)),tail*) -> {return `TwoC1(TwoC0(TwoId(head.source()),f,TwoId(tail.source())),TwoC0(head,g,tail));} 
 	 } 
}

%strategy HorizontalSplitting() extends Fail(){ 
  	visit TwoPath {
  	  TwoId(OneC0(head,tail*)) -> { return `TwoC0(TwoId(head),TwoId(tail*)); }

 	 } 
}

//ˆ faire ensuite : stratgies pour dtecter les sources des 3-cellules







/*==>dans le .gom maintenant et avec quelques erreurs en moins 
//pour chacune des fonctions suivantes, on suppose les chemins pralablement bien forms (pour l'instant)
//il faudra vrifier ˆ un moment que c'est bien form mais les fonctions pour vrifier utilisent des fonctions qui fonctionnent si c'est djˆ bien form
//donc il va falloir affiner tout a
public static OnePath twoS1(TwoPath t){
%match (t){
			TwoId(X) -> { return `X; }
			TwoCell[Source=x] -> { return `x; }
			TwoC0(head,tail*) -> { return `OneC0(twoS1(head),twoS1(tail*)); }
			TwoC1(head,tail*) -> { return twoS1(`head); }
}
//return `OneId();
throw new tom.engine.exception.TomRuntimeException("strange term: "+t);
}

public static OnePath twoT1(TwoPath t){
%match (t){
			TwoId(X) -> { return `X; }
			TwoCell[Target=x] -> { return `x; }
			TwoC0(head,tail*) -> { return `OneC0(twoT1(head),twoT1(tail*)); }
			TwoC1(head*,tail) -> { return twoT1(`tail); }
}
//return `OneId();
throw new tom.engine.exception.TomRuntimeException("strange term: "+t);
}

public static OnePath threeS1(ThreePath t){
%match (t){	
			ThreeId(X) -> { return `twoS1(X); }
			ThreeCell[Source=x] -> { return `twoS1(x); }
			ThreeC0(head,tail*) -> { return `OneC0(threeS1(head),threeS1(tail*)); }
			ThreeC1(head,tail*) -> { return threeS1(`head); }
			ThreeC2(head,tail*) -> { return threeS1 (`head); }
}
//return `OneId();
throw new tom.engine.exception.TomRuntimeException("strange term: "+t);
}

public static OnePath threeT1(ThreePath t){
%match (t){
			ThreeId(X) -> { return `twoT1(X); }
			ThreeCell[Target=x] -> { return `twoT1(x); }
			ThreeC0(head,tail*) -> { return `OneC0(threeT1(head),threeT1(tail*)); }
			ThreeC1(head*,tail) -> { return threeT1(`tail); }
			ThreeC2(head,tail*) -> { return threeT1 (`head); }
}
//return `OneId();
throw new tom.engine.exception.TomRuntimeException("strange term: "+t);
}

public static TwoPath threeS2(ThreePath t){
%match (t){
			ThreeId(X) -> { return `X; }
			ThreeCell[Source=x] -> { return `x; }
			ThreeC0(head,tail*) -> { return `TwoC0(threeS2(head),threeS2(tail*)); }
			ThreeC1(head,tail*) -> { return `TwoC1(threeS2(head),threeS2(tail*)); }
			ThreeC2(head,tail*) -> { return threeS2 (`head); }
}
//return `TwoId(OneId());
throw new tom.engine.exception.TomRuntimeException("strange term: "+t);
}

public static TwoPath threeT2(ThreePath t){
%match (t){
			ThreeId(X) -> { return `X; }
			ThreeCell[Target=x] -> { return `x; }
			ThreeC0(head,tail*) -> { return `TwoC0(threeT2(head),threeT2(tail*)); }
			ThreeC1(head,tail*) -> { return `TwoC1(threeT2(head),threeT2(tail*)); }
			ThreeC2(head*,tail) -> { return threeT2 (`tail); }
}
//return `TwoId(OneId());
throw new tom.engine.exception.TomRuntimeException("strange term: "+t);
}

public static boolean oneDefined(OnePath o){return true;}

public static boolean twoDefined(TwoPath t){
%match (t){
			TwoCell[] -> { return true; }
			TwoC0(_*) -> { return true; }
			TwoC1(head, tail*) -> { return `twoT1(head)==`twoS1(tail)&&twoDefined(`tail);}
	}
return false;
}

public static boolean threeDefined(ThreePath t){
%match (t){
			ThreeCell[] -> { return true; }
			ThreeC0(_*) -> { return true; }
			ThreeC1(ThreeCell[Source=source1],ThreeCell[Source=source2],tail*) -> { return `twoT1(source1)==`twoS1(source2)&&threeDefined(`tail);}
			ThreeC2(ThreeCell[Target=target1],ThreeCell[Source=source2],tail*) -> { return `target1==`source2&&threeDefined(`tail);}
	}
return false;
}
*/

}