\documentclass[11pt]{article}
\usepackage[latin1]{inputenc}
%% \usepackage{fullpage}
\usepackage{color}
\usepackage{aeguill}
\usepackage{comment}

%% \includecomment{versionProf}
\specialcomment{versionProf}
    {\begingroup\bf}{\endgroup}

%% UNCOMMENT IF YOU WANT THE SHORT VERSION
\excludecomment{versionProf}

\title{Termes, réécriture, filtrage syntaxique}
\date{2005-2006}
\author{M1}


\begin{document}

%% \thispagestyle{empty}
%% \centerline{\LARGE\textbf{Termes, réécriture, filtrage syntaxique}}
%% \bigskip
%% \bigskip
\maketitle

Ce premier TD a pour but de vous familiariser la réécriture sur les
termes et avec la notion sous-jacente de filtrage. Nous abordons dans
ce TD seulement le filtrage syntaxique.

\section{Arithmétique  de Peano}

On souhaite écrire le système de réécriture permettant de calculer la
somme d'entiers de Peano. \\
\textit{Rappel}: L'entier $n$ est représenté par le terme
suc(suc(...(suc($0$)))) avec $n$ occurrence de «suc» et la somme est
calculée en utilisant les égalités suivantes:
%
\begin{itemize}
\item[] x + zero = x
\item[] x + suc(y) = suc(x + y)
\item[] x * zero = zero 
\item[] x * suc(y) = x + (x*y)
\end{itemize}

En utilisant le système obtenu calculer les sommes $2+2$ et $1+1+1+1$. 

\begin{versionProf}
\begin{verbatim}
x + zero -> x
x + suc(y) -> suc(x + y)
x * zero -> zero 
x * suc(y) -> x + (x*y)

Start = plus(suc(suc(zero)),suc(suc(zero))) 
Step = suc(plus(suc(suc(zero)),suc(zero)))
Step = suc(suc(plus(suc(suc(zero)),zero)))
Step = suc(suc(suc(suc(zero))))
Step = suc(suc(suc(suc(zero))))

Start = plus(plus(suc(zero),suc(zero)),plus(suc(zero),suc(zero)))
Step = plus(plus(suc(zero),suc(zero)),suc(plus(suc(zero),zero)))
Step = suc(plus(plus(suc(zero),suc(zero)),plus(suc(zero),zero)))
Step = suc(plus(plus(suc(zero),suc(zero)),suc(zero)))
Step = suc(suc(plus(plus(suc(zero),suc(zero)),zero)))
Step = suc(suc(plus(suc(zero),suc(zero))))
Step = suc(suc(suc(plus(suc(zero),zero))))
Step = suc(suc(suc(suc(zero))))
Step = suc(suc(suc(suc(zero))))

Start = plus(suc(zero),plus(suc(zero),plus(suc(zero),suc(zero))))
Step = plus(suc(zero),plus(suc(zero),suc(plus(suc(zero),zero))))
Step = plus(suc(zero),suc(plus(suc(zero),plus(suc(zero),zero))))
Step = suc(plus(suc(zero),plus(suc(zero),plus(suc(zero),zero))))
Step = suc(plus(suc(zero),plus(suc(zero),suc(zero))))
Step = suc(plus(suc(zero),suc(plus(suc(zero),zero))))
Step = suc(suc(plus(suc(zero),plus(suc(zero),zero))))
Step = suc(suc(plus(suc(zero),suc(zero))))
Step = suc(suc(suc(plus(suc(zero),zero))))
Step = suc(suc(suc(suc(zero))))
Step = suc(suc(suc(suc(zero))))

\end{verbatim}
\end{versionProf}

\section{Fibonacci}

On souhaite écrire le système de réécriture permettant de calculer la
suite de Fibonacci:
\begin{itemize}
\item[] fib(0) = 1
\item[] fib(1) = 1
\item[] fib(n) = fib(n-1)+fib(n-2)
\end{itemize}

\begin{versionProf}
Il faut utiliser la réécriture conditionnelle: 
\begin{verbatim}
fib(0) -> 1
fib(1) -> 1
fib(n) -> fib(n-1)+fib(n-2)     if n>1
\end{verbatim}
\end{versionProf}


\section{Polynômes}

On considère des polynômes de la forme: $2X^3+4X^2+5X+1$ et on
souhaite calculer leurs dérivés par rapport à $X$.

\subsection{Dérivé}
On souhaite calculer écrire le système de réécriture permettant de
calculer la dérivé de tout polynôme en sachant que:
\begin{itemize}
\item[] $deriv(n,X) = 0$
\item[] $deriv(m*X^n,X) = m*n*X^{n-1}$
\item[] $deriv(P1+P2,X) = deriv(P1,X) + deriv(P2,X)$
\item[] $deriv(P1*P2,X) = deriv(P1,X) * P2 + deriv(P2,X) * P1$
\end{itemize}

Montrer les étapes de réduction pour obtenir la dérivé des polynômes
$3*X^2+X+7$ et $5*X^2+3*X+4$ ainsi que de leur somme.

\begin{versionProf}
\begin{itemize}
\item[] $deriv(n,X) -> 0$
\item[] $deriv(mX^n,X) -> mnX^{n-1}$
\item[] $deriv(P1+P2,X) -> deriv(P1,X) + deriv(P2,X)$
\item[] $deriv(P1*P2,X) -> deriv(P1,X) * P2 + deriv(P2,X) * P1$
\end{itemize}

$6*X+1 + 10*X+3$
\end{versionProf}


\subsection{Simplification}

Le résultat obtenu à la question précédente ne respecte pas la forme
demandée; c.a.d. un seul monôme pour chaque puissance de $X$ et les
monômes triés par ordre décroissant.

Proposez un système de réécriture permettant de résoudre ce
problème. Appliquez-le au résultat obtenu précédemment.

\begin{versionProf}
\begin{itemize}
\item[] $simplify(m_1 X^n + m_2 X^n) -> (m_1+m_2) X^n$
\item[] $simplify(m_1 X^{n_1} + m_2 X^{n_2}) -> m_2 X^{n_2} + m_1 X^{n_1}$
  ~~~~~~if $n_1 < n_2$

\item[] $simplify(m_1 X^n + (m_2 X^n + P)) -> (m_1+m_2) X^n + P$
\item[] $simplify(m_1 X^{n_1} + (m_2 X^{n_2} + P)) -> 
  m_2 X^{n_2} + (m_1 X^{n_1} + P)$
  ~~~~~~if $n_1 < n_2$

\item[] $simplify((P_1 + P_2) + P_3) -> P_1 + (P_2 + P_3) X^n$
\end{itemize}
\end{versionProf}

%% \subsection{Multiplication}



\section{Filtrage syntaxique}

\begin{enumerate}
\item
On considère des problèmes de filtrage linéaires syntaxique sur les
entiers de Peano. On souhaite écrire le système de réécriture
permettant de résoudre ces problèmes.

Par exemple, le résultat du problème $(x+0)+(y+0) \ll (0+0)+(0+0)$
doit être $x\ll 0 \wedge y\ll 0$ et  $(x+0)+(y+0) \ll (0+0)+(0+1)$
doit être réduit a $False$.

\begin{versionProf}
\begin{verbatim}
    // Delete
    Match(zero(),zero()) -> True()
      
    // Decompose
      Match(suc(x),suc(y)) -> Match(x,y)
      Match(plus(x1,x2),plus(y1,y2)) -> And(Match(x1,y1),Match(x2,y2))
        
    // SymbolClash
      Match(suc(_),zero()) -> False() 
      Match(zero(),suc(_)) -> False() 
      Match(plus(_,_),zero()) -> False() 
      Match(zero(),plus(_,_)) -> False() 
      Match(suc(_),plus(_,_)) -> False() 
      Match(plus(_,_),suc(_)) -> False() 

    // PropagateClash
    And(False(),_) -> False()
    And(_,False()) -> False()

    // PropagateSuccess
      And(True(),X) -> X
      And(X,True()) -> X

    // Merging
    And(X,X) -> X
\end{verbatim}

\begin{verbatim}
Match(plus(plus(var("x"),zero),plus(var("x"),zero)),
      plus(plus(zero,zero),plus(zero,zero)))
= 
And(Match(var("x"),zero),True)

Match(plus(plus(var("x"),zero),plus(var("y"),zero)),
      plus(plus(zero,zero),plus(zero,zero)))
= 
And(And(Match(var("x"),zero),True),And(Match(var("y"),zero),True))
\end{verbatim}
si on oublie la Com pour Propagate

\begin{verbatim}
Match(plus(plus(var("x"),zero),plus(var("x"),zero)),
      plus(plus(zero,zero),plus(zero,zero)))
= 
Match(var("x")e,zero)

Match(plus(plus(var("x"),zero),plus(var("y"),zero)),
      plus(plus(zero,zero),plus(zero,zero)))
= 
And(Match(var("x"),zero),Match(var("y"),zero))
\end{verbatim}
\end{versionProf}

\item
On souhaite généraliser le système de réécriture obtenu afin de
résoudre des problèmes de filtrage non-linéaires.

Par exemple, le résultat du problème $(x+y)+(z+x) \ll (0+0)+(0+0)$
doit être $x\ll 0 \wedge y\ll 0 \wedge z\ll 0$ et $(x+y)+(y+x) \ll
(0+0)+(0+1)$ doit être réduit a $False$.

\begin{versionProf}
\begin{verbatim}
    // Delete
      Match(zero(),zero()) -> True()
      
    // Decompose
      Match(suc(x),suc(y)) -> Match(x,y)
      Match(plus(x1,x2),plus(y1,y2)) -> And(Match(x1,y1),Match(x2,y2))
        
    // SymbolClash
      Match(suc(_),zero()) -> False() 
      Match(zero(),suc(_)) -> False() 
      Match(plus(_,_),zero()) -> False() 
      Match(zero(),plus(_,_)) -> False() 
      Match(suc(_),plus(_,_)) -> False() 
      Match(plus(_,_),suc(_)) -> False() 

    // PropagateClash
      And(False(),_) -> False()
      And(_,False()) -> False()

    // PropagateSuccess
      And(True(),X) -> X
      And(X,True()) -> X

    // Merging
      And(X,X) -> X
      And(X,And(X,Y)) ->  And(X,Y)

    // MergingFail
      And(Match(var(x),X),Match(var(x),Y)) -> False() 
        if(X!=Y)
      And(Match(var(x),X),And(Match(var(x),Y),P)) -> False() 
        if(X!=Y)

    // Sort
      And(Match(var(x),X),Match(var(y),Y)) -> 
         And(Match(var(y),Y),Match(var(x),X)) ;
            if(x.compareTo(y)<0){
      And(Match(var(x),X),And(Match(var(y),Y),P)) -> 
         And(Match(var(y),Y),And(Match(var(x),X),P)) 
            if(x.compareTo(y)<0)
    
    // Assoc
      And(And(p1,p2),p3) -> And(p1, And(p2,p3))

    // congruence
      And(p1,p2) -> And(solve(p1),solve(p2))
\end{verbatim}
\end{versionProf}
\end{enumerate}

\end{document}
