//Licence
package tom.mapping.dsl.generator.tom

import tom.mapping.model.*
import org.eclipse.emf.ecore.*
import tom.mapping.dsl.generator.TomMappingExtensions
import tom.mapping.dsl.generator.NamingCompiler
import org.eclipse.xtext.generator.IFileSystemAccess
import com.google.inject.Inject
import tom.mapping.dsl.generator.ImportsCompiler
import com.sun.tools.javac.util.List

class TomFactoryCompiler {
	
	extension TomMappingExtensions = new TomMappingExtensions()
	extension NamingCompiler = new NamingCompiler()
	
	String prefix = "tom"
	
	@Inject ImportsCompiler injco
	@Inject OperatorsCompiler injop
	@Inject ParametersCompiler injpa
	
	def compile(Mapping m, IFileSystemAccess fsa) {
		fsa.generateFile(prefix+"/"+m.name.toFirstLower()+"/internal/"+m.tomFactoryName()+".java", m.main());
	}
	
	def main(Mapping map){
	'''
	 package Â«getPackagePrefix(prefix)Â»Â«map.name.toFirstLower()Â».internal;
	 
	 /* PROTECTED REGION ID(map.name+"_tom_factory_imports") ENABLED START */
	 // protected imports, you should add here required imports that won't be removed after regeneration of the maping code
	  
	 import java.util.List 
	  
	 Â«injco.imports(map)Â»
	 /* ENDPROTECT */
	 
	 /**
	 * Factory used by TOM for Â«map.nameÂ» mapping.
	 * It shouldn't be visible outside of the plugin
	 * -- Generated by TOM mapping EMF generator --
	 */
	 
	 
	 public class Â«tomFactoryName(map)Â» {
	 	
	 	/* PROTECTED REGION ID(map.name+"_tom_factory_instances") ENABLED START */
	 	
	 	Â«val packageList = map.operators.filter[j | j instanceof ClassOperator].collect(e | e.class_.EPackage);Â»										// What is collect ?
	 	Â«for(package: packageList.filter[!e | packageList.filter[f | e.name == f.name && e!=f]])Â» {													// Ok for "reject" ?
	 		public static Â«package.name.toFirstUpper()Â»Factory Â«package.nameÂ»Factory = Â«package.name.toFirstUpper)Â»Factory.eINSTANCE;
	 	}
	 	
	 	Â«val packageList = map.allDefaultOperators.collect(e | e.EPackage);Â»																			// What is collect ?
	 	Â«for(package: packageList.filter[!e | packageList.filter[f | e.name == f.name && e!=f]])Â» {													// Ok for "reject" ?
	 		public static Â«package.name.toFirstUpper()Â»Factory Â«package.nameÂ»Factory = Â«package.name.toFirstUpper)Â»Factory.eINSTANCE;
	 	}
	 }
	 	/* ENDPROTECT */
	 
	 
	 // User operators Â«map.operatorsÂ»
	 
	 Â«for(module: map.modules)Â» {
	 	/** Module Â«module.nameÂ» **/
	 	for(op: module.operators) {
	 		// Operator Â«op.nameÂ»
	 		Â«operator(map,op);Â»
	 	}
	 }
	 
	 /*
	 * Default TOM operators for Â«map.nameÂ» mapping. Each class that has a terminal type has aloso a default create function.
	 */
	 
	 Â«for(op: map.allDefaultOperators)Â»{
	 	Â«if(!op.instanceClassName.contains("java.util.Map$Entry")Â» {
	 		Â«javaFactoryCreateDefaultOperator(map,op.name,op);Â»
	 	}
	 }
	 '''
	} 


	def operator(Mapping mapping, Operator op) {
		'''// Â«op.eClass().nameÂ»'''
	}

	
	def operator(Mapping mapping, ClassOperator clop) {
		if(clop.parameters.size>0) {
			val parameters = getCustomParameters(clop) as List<FeatureParameter>;
			javaFactoryCreateOperatorWithParameters(parameters, mapping, clop);											// Encore le problme List[] ou List<>. Cast sans doute provisoire
		} else {
			javaFactoryCreateDefaultOperator(mapping, clop.name, clop.class_);
		}
	}


	def javaFactoryCreateOperatorWithParameters(List<FeatureParameter> parameters, Mapping mapping, ClassOperator clop) {
	'''	
	// CreateOperatorWithParameters Â«clop.nameÂ»
	public static Â«clop.class_.nameÂ» createÂ«clop.name.toFirstUpper()Â»(Â«for(p: parameters SEPARATOR ","Â» {Â«typeOfParameter(mapping, p.feature)Â» _Â«p.feature.nameÂ»}) {
		Â«clop.class_.nameÂ» o = Â«clop.class_.EPackage.nameÂ»Factory.createÂ«clop.class_.name.toFirstUpper()Â»();
		Â«for(p: parameters)Â» {
			Â«structureFeatureSetter(p.feature)Â»;
		}
		Â«for(p: clop.getSettedCustomParameters())Â» {
			o.setÂ«p.feature.name.toFirstUpper()Â»(Â«injop.settedValue(p.feature, p.value)Â»;
		}
		return o;
	}
	'''
	}
	
	
	def javaFactoryCreateDefaultOperator(Mapping mapping, String name, EClass ecl) {
		val parameters = getDefaultParameters(ecl,mapping);
		'''
		// CreateDefaultOperator Â«ecl.nameÂ»
		public static Â«ecl.nameÂ» createÂ«ecl.name.toFirstUpper()Â»(Â«injop.javaClassAttributes(mapping, ecl);Â»
		Â«for(p: parameters SEPARATOR ",")Â»{Â«typeOfParameter(mapping, p)Â» _Â«p.nameÂ»}) {
			Â«ecl.nameÂ» o = Â«EPackage.nameÂ»Factory createÂ«ecl.name.toFirstUpper()Â»();
			Â«for(attribute: ecl.EAllAttributes)Â» {
				structureFeatureSetter(attribute);
			}
		}
		Â«for(param: parameters)Â» {
			Â«structureFeatureSetter(param)Â»;
		}
		return o;
		'''
	}
	
	
	def structureFeatureSetter(EStructuralFeature esf) {
		if(esf.many) {
			'''
			for(int i=0; i<_Â«esf.nameÂ».size(); i++) {
				o.getÂ«name.toFirstUpper()Â»().add(Â«featureAccess(esf)Â».get(i));
			}
			'''
		} else {
			'''
			o.setÂ«ecl.name.toFirstUpper()Â»(Â«featureAccess(esf)Â»);
			'''
		}
	}
	
	
	def featureAccess(EStructuralFeature esf) {
		'''
		Â«if(esf.EType.instanceTypeName == null)Â» {
			Â«esf.EType.nameÂ»; }
			_Â«esf.nameÂ»;
			'''
	}
	
	
	def typeOfParameter(Mapping mapping, EStructuralFeature esf) {}
	
	def dispatch typeOfParameter(Mapping mapping, EReference eref) {terminalTypeName(mapping, eref.many, eref.EType);}
	
	def dispatch typeOfParameter(Mapping mapping, EEnum enum) {enum.name;}
	
	def dispatch typeOfParameters(Mapping mapping, EAttribute eat) {injpa.primitiveType(eat.EAttributeType);}
	
	
	def dispatch terminalTypeName(Mapping mapping, boolean many, EClassifier ecl) {
		if(many) {
			'''
			List<''' } '''Â«ecl.nameÂ»''' 
			if(many) {
			'''>'''}
	}
	
	def dispatch terminalTypeName(Mapping mapping, boolean many, EClass ecl) {
		if(many) {
			'''
			List<''' } '''Â«mapping.getTerminal(ecl,false).class_.nameÂ»''' 
			if(many) {
			'''>'''}
	}


	def javaClassAttributes(Mapping mapping, EClass ecl) {
		'''
		Â«for(att: ecl.EAllAttributes SEPARATOR ",")Â» {
			Â«typeOfParameter(mapping, att)Â» _Â«att.nameÂ»
		}
		Â«if(ecl.EAllAttribute.size > 0 && ecl.getDefaultParameters(mapping).size > 0)Â» {,}
		'''
	}
	
	
}